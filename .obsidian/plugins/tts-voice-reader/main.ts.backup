import { App, Plugin, PluginSettingTab, Setting, Notice, Modal, Menu, Editor, MarkdownView } from 'obsidian';

interface TTSSettings {
    voiceMode: 'browser' | 'custom';
    browserVoice: string;
    speed: number;
    pitch: number;
    volume: number;
    language: string;
    customVoiceData: string | null;
    autoSaveAudio: boolean;
    outputFolder: string;
    dashboardFolder: string;
}

const DEFAULT_SETTINGS: TTSSettings = {
    voiceMode: 'browser',
    browserVoice: '',
    speed: 1.0,
    pitch: 1.0,
    volume: 1.0,
    language: 'ko-KR',
    customVoiceData: null,
    autoSaveAudio: false,
    outputFolder: 'TTS Audio',
    dashboardFolder: 'TTS Dashboard'
}

export default class TTSVoiceReaderPlugin extends Plugin {
    settings: TTSSettings;
    synthesis: SpeechSynthesis;
    currentUtterance: SpeechSynthesisUtterance | null = null;
    isPlaying: boolean = false;
    availableVoices: SpeechSynthesisVoice[] = [];
    mediaRecorder: MediaRecorder | null = null;
    recordedChunks: Blob[] = [];
    currentAudio: HTMLAudioElement | null = null;
    currentSpeakingText: string = ''; // í˜„ì¬ ì½ê³  ìˆëŠ” í…ìŠ¤íŠ¸ (ìë™ ì €ì¥ìš©)

    async onload() {
        await this.loadSettings();
        this.synthesis = window.speechSynthesis;

        // ìŒì„± ëª©ë¡ ë¡œë“œ
        this.loadVoices();
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = () => this.loadVoices();
        }

        // ë¦¬ë³¸ ì•„ì´ì½˜
        this.addRibbonIcon('mic', 'TTS ìŒì„± ì½ê¸°', () => {
            const activeView = this.app.workspace.getActiveViewOfType(MarkdownView);
            if (activeView) {
                const editor = activeView.editor;
                const selectedText = editor.getSelection();
                if (selectedText) {
                    this.speakText(selectedText);
                } else {
                    new TTSReaderModal(this.app, this).open();
                }
            } else {
                new TTSReaderModal(this.app, this).open();
            }
        });

        // ì»¤ë§¨ë“œ: ì„ íƒí•œ í…ìŠ¤íŠ¸ ì½ê¸°
        this.addCommand({
            id: 'speak-selection',
            name: 'ì„ íƒí•œ í…ìŠ¤íŠ¸ ì½ê¸°',
            editorCallback: (editor: Editor) => {
                const text = editor.getSelection();
                if (text) {
                    this.speakText(text);
                } else {
                    new Notice('í…ìŠ¤íŠ¸ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”');
                }
            }
        });

        // ì»¤ë§¨ë“œ: ì „ì²´ ë…¸íŠ¸ ì½ê¸°
        this.addCommand({
            id: 'speak-entire-note',
            name: 'ì „ì²´ ë…¸íŠ¸ ì½ê¸°',
            editorCallback: (editor: Editor) => {
                const text = editor.getValue();
                this.speakText(text);
            }
        });

        // ì»¤ë§¨ë“œ: ì •ì§€
        this.addCommand({
            id: 'stop-speaking',
            name: 'ìŒì„± ì½ê¸° ì •ì§€',
            callback: () => {
                this.stopSpeaking();
            }
        });

        // ì»¤ë§¨ë“œ: ì¼ì‹œì •ì§€/ì¬ê°œ
        this.addCommand({
            id: 'pause-resume-speaking',
            name: 'ìŒì„± ì½ê¸° ì¼ì‹œì •ì§€/ì¬ê°œ',
            callback: () => {
                this.togglePause();
            }
        });

        // ì»¤ë§¨ë“œ: ìŒì„± ë…¹ìŒ
        this.addCommand({
            id: 'record-voice',
            name: 'ë‚´ ìŒì„± ë…¹ìŒí•˜ê¸°',
            callback: () => {
                new VoiceRecordModal(this.app, this).open();
            }
        });

        // ì»¤ë§¨ë“œ: ëŒ€ì‹œë³´ë“œ ìƒì„±
        this.addCommand({
            id: 'create-dashboard',
            name: 'TTS ëŒ€ì‹œë³´ë“œ ìƒì„±',
            callback: async () => {
                await this.createDashboard();
            }
        });

        // ì„¤ì • íƒ­
        this.addSettingTab(new TTSSettingTab(this.app, this));

        // ì»¨í…ìŠ¤íŠ¸ ë©”ë‰´
        this.registerEvent(
            this.app.workspace.on('editor-menu', (menu: Menu, editor: Editor) => {
                const selection = editor.getSelection();
                if (selection) {
                    menu.addItem((item) => {
                        item
                            .setTitle('ğŸ”Š ì„ íƒí•œ í…ìŠ¤íŠ¸ ì½ê¸°')
                            .setIcon('mic')
                            .onClick(() => {
                                this.speakText(selection);
                            });
                    });
                }
            })
        );
    }

    loadVoices() {
        this.availableVoices = this.synthesis.getVoices();
        
        // í•œêµ­ì–´ ìŒì„± ìë™ ì„ íƒ
        if (!this.settings.browserVoice && this.availableVoices.length > 0) {
            const koreanVoice = this.availableVoices.find(voice => 
                voice.lang.startsWith('ko')
            );
            this.settings.browserVoice = koreanVoice?.name || this.availableVoices[0]?.name || '';
        }
    }

    speakText(text: string) {
        // ì´ì „ ìŒì„± ì •ì§€
        this.stopSpeaking();

        // ë§ˆí¬ë‹¤ìš´ ë¬¸ë²• ì œê±°
        const cleanText = this.cleanMarkdown(text);

        // í˜„ì¬ ì½ëŠ” í…ìŠ¤íŠ¸ ì €ì¥ (ì¤‘ì§€ ì‹œ ìë™ ì €ì¥ìš©)
        this.currentSpeakingText = cleanText;

        if (this.settings.voiceMode === 'browser') {
            new Notice('ğŸŒ ë¸Œë¼ìš°ì € TTS ëª¨ë“œë¡œ ì¬ìƒ');
            this.speakWithBrowser(cleanText);
        } else {
            // ì»¤ìŠ¤í…€ ìŒì„± - ë…¹ìŒëœ ìŒì„± ì¬ìƒ
            if (this.settings.customVoiceData) {
                new Notice('ğŸ­ ìƒ˜í”Œ ì˜¤ë””ì˜¤ ì¬ìƒ (í…ìŠ¤íŠ¸ì™€ ë¬´ê´€)');
                this.speakWithCustomVoice(cleanText);
            } else {
                new Notice('âš ï¸ ë…¹ìŒëœ ìŒì„±ì´ ì—†ì–´ ë¸Œë¼ìš°ì € TTSë¡œ ì¬ìƒí•©ë‹ˆë‹¤');
                // í´ë°±: ë¸Œë¼ìš°ì € TTS ì‚¬ìš©
                this.speakWithBrowser(cleanText);
            }
        }
    }

    async speakWithCustomVoice(text: string) {
        try {
            new Notice('ğŸ­ ë‚´ ëª©ì†Œë¦¬ë¡œ ì½ê¸° ì‹œì‘...');
            
            // Base64 ë°ì´í„°ë¥¼ Blobìœ¼ë¡œ ë³€í™˜
            const base64Data = this.settings.customVoiceData;
            if (!base64Data) {
                throw new Error('ìŒì„± í”„ë¡œí•„ì´ ì—†ìŠµë‹ˆë‹¤');
            }

            // Base64ë¥¼ Blobìœ¼ë¡œ ë³€í™˜
            const response = await fetch(base64Data);
            const blob = await response.blob();
            
            // Audio ê°ì²´ ìƒì„±
            const audioUrl = URL.createObjectURL(blob);
            this.currentAudio = new Audio(audioUrl);
            
            this.currentAudio.onplay = () => {
                this.isPlaying = true;
                new Notice('ğŸ”Š ìŒì„± ì¬ìƒ ì¤‘...');
            };

            this.currentAudio.onended = async () => {
                this.isPlaying = false;
                URL.revokeObjectURL(audioUrl);
                this.currentAudio = null;
                new Notice('âœ… ì¬ìƒ ì™„ë£Œ');
                
                // ìë™ ì €ì¥ì´ í™œì„±í™”ëœ ê²½ìš°
                if (this.settings.autoSaveAudio) {
                    try {
                        await this.saveTTSAsFile(text);
                    } catch (error) {
                        console.error('TTS ìë™ ì €ì¥ ì‹¤íŒ¨:', error);
                    }
                }
            };

            this.currentAudio.onerror = (error) => {
                console.error('Audio playback error:', error);
                this.isPlaying = false;
                URL.revokeObjectURL(audioUrl);
                this.currentAudio = null;
                new Notice('âŒ ìŒì„± ì¬ìƒ ì‹¤íŒ¨. ë¸Œë¼ìš°ì € TTSë¡œ ì „í™˜í•©ë‹ˆë‹¤.');
                // í´ë°±: ë¸Œë¼ìš°ì € TTS
                this.speakWithBrowser(text);
            };

            // ë³¼ë¥¨ ì„¤ì • ì ìš©
            this.currentAudio.volume = this.settings.volume;
            
            // ì¬ìƒ
            await this.currentAudio.play();

            // í…ìŠ¤íŠ¸ ì •ë³´ í‘œì‹œ (ì„ íƒì‚¬í•­)
            console.log('ì¬ìƒí•  í…ìŠ¤íŠ¸:', text.substring(0, 100) + '...');
            new Notice(`ğŸ“ í…ìŠ¤íŠ¸ ê¸¸ì´: ${text.length}ì (ë…¹ìŒëœ ìƒ˜í”Œ ì¬ìƒ)`);
            
        } catch (error) {
            console.error('Custom voice playback error:', error);
            new Notice('âŒ ë‚´ ëª©ì†Œë¦¬ ì¬ìƒ ì‹¤íŒ¨: ' + error.message + '. ë¸Œë¼ìš°ì € TTSë¡œ ì „í™˜í•©ë‹ˆë‹¤.');
            // í´ë°±: ë¸Œë¼ìš°ì € TTS
            this.speakWithBrowser(text);
        }
    }

    speakWithBrowser(text: string) {
        const utterance = new SpeechSynthesisUtterance(text);
        
        // ì„¤ì • ì ìš©
        const voice = this.availableVoices.find(v => v.name === this.settings.browserVoice);
        if (voice) {
            utterance.voice = voice;
        }
        
        utterance.rate = this.settings.speed;
        utterance.pitch = this.settings.pitch;
        utterance.volume = this.settings.volume;
        utterance.lang = this.settings.language;

        // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
        utterance.onstart = () => {
            this.isPlaying = true;
            new Notice('ğŸ”Š ìŒì„± ì½ê¸° ì‹œì‘');
        };

        utterance.onend = async () => {
            this.isPlaying = false;
            this.currentUtterance = null;
            new Notice('âœ… ìŒì„± ì½ê¸° ì™„ë£Œ');
            
            // ìë™ ì €ì¥ì´ í™œì„±í™”ëœ ê²½ìš° TTS ì¶œë ¥ì„ íŒŒì¼ë¡œ ì €ì¥
            if (this.settings.autoSaveAudio) {
                try {
                    await this.saveTTSAsFile(text);
                } catch (error) {
                    console.error('TTS ìë™ ì €ì¥ ì‹¤íŒ¨:', error);
                }
            }
        };

        utterance.onerror = (event) => {
            this.isPlaying = false;
            this.currentUtterance = null;
            new Notice('âŒ ìŒì„± ì½ê¸° ì˜¤ë¥˜: ' + event.error);
        };

        this.currentUtterance = utterance;
        this.synthesis.speak(utterance);
    }

    async saveTTSAsFile(text: string) {
        try {
            const folderPath = this.settings.outputFolder;
            const folder = this.app.vault.getAbstractFileByPath(folderPath);
            
            if (!folder) {
                await this.app.vault.createFolder(folderPath);
            }

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `tts_${timestamp}.txt`;
            const filePath = `${folderPath}/${filename}`;
            
            const content = `# TTS ìŒì„± í…ìŠ¤íŠ¸\n\nìƒì„±: ${new Date().toLocaleString('ko-KR')}\nìŒì„± ëª¨ë“œ: ${this.settings.voiceMode}\nì–¸ì–´: ${this.settings.language}\n\n---\n\n${text}`;
            
            await this.app.vault.create(filePath, content);
            new Notice(`âœ… TTS í…ìŠ¤íŠ¸ ì €ì¥: ${filename}`);
        } catch (error) {
            console.error('TTS íŒŒì¼ ì €ì¥ ì‹¤íŒ¨:', error);
            throw error;
        }
    }

    async stopSpeaking() {
        // ìë™ ì €ì¥ì´ í™œì„±í™”ë˜ì–´ ìˆê³  í˜„ì¬ ì½ê³  ìˆëŠ” í…ìŠ¤íŠ¸ê°€ ìˆìœ¼ë©´ ì €ì¥
        if (this.settings.autoSaveAudio && this.currentSpeakingText && (this.synthesis.speaking || this.currentAudio)) {
            try {
                await this.saveTTSAsFile(this.currentSpeakingText);
            } catch (error) {
                console.error('ì¤‘ì§€ ì‹œ ìë™ ì €ì¥ ì‹¤íŒ¨:', error);
            }
        }

        // ë¸Œë¼ìš°ì € TTS ì •ì§€
        if (this.synthesis.speaking) {
            this.synthesis.cancel();
            this.isPlaying = false;
            this.currentUtterance = null;
        }
        
        // ì»¤ìŠ¤í…€ ì˜¤ë””ì˜¤ ì •ì§€
        if (this.currentAudio) {
            this.currentAudio.pause();
            this.currentAudio.currentTime = 0;
            const audioUrl = this.currentAudio.src;
            if (audioUrl.startsWith('blob:')) {
                URL.revokeObjectURL(audioUrl);
            }
            this.currentAudio = null;
            this.isPlaying = false;
        }

        // í˜„ì¬ í…ìŠ¤íŠ¸ ì´ˆê¸°í™”
        this.currentSpeakingText = '';
        
        new Notice('â¹ï¸ ìŒì„± ì½ê¸° ì •ì§€');
    }

    togglePause() {
        // ì»¤ìŠ¤í…€ ì˜¤ë””ì˜¤ ì¼ì‹œì •ì§€/ì¬ê°œ
        if (this.currentAudio) {
            if (this.currentAudio.paused) {
                this.currentAudio.play();
                new Notice('â–¶ï¸ ì¬ê°œ');
            } else {
                this.currentAudio.pause();
                new Notice('â¸ï¸ ì¼ì‹œì •ì§€');
            }
            return;
        }
        
        // ë¸Œë¼ìš°ì € TTS ì¼ì‹œì •ì§€/ì¬ê°œ
        if (this.synthesis.speaking) {
            if (this.synthesis.paused) {
                this.synthesis.resume();
                new Notice('â–¶ï¸ ì¬ê°œ');
            } else {
                this.synthesis.pause();
                new Notice('â¸ï¸ ì¼ì‹œì •ì§€');
            }
        }
    }

    cleanMarkdown(text: string): string {
        return text
            .replace(/^#+\s+/gm, '') // í—¤ë”
            .replace(/\*\*(.+?)\*\*/g, '$1') // êµµê²Œ
            .replace(/\*(.+?)\*/g, '$1') // ê¸°ìš¸ì„
            .replace(/~~(.+?)~~/g, '$1') // ì·¨ì†Œì„ 
            .replace(/\[(.+?)\]\(.+?\)/g, '$1') // ë§í¬
            .replace(/!\[.*?\]\(.+?\)/g, '') // ì´ë¯¸ì§€
            .replace(/```[\s\S]*?```/g, '') // ì½”ë“œ ë¸”ë¡
            .replace(/`(.+?)`/g, '$1') // ì¸ë¼ì¸ ì½”ë“œ
            .replace(/^\s*[-*+]\s+/gm, '') // ë¦¬ìŠ¤íŠ¸
            .replace(/^\s*\d+\.\s+/gm, '') // ë²ˆí˜¸ ë¦¬ìŠ¤íŠ¸
            .replace(/^\s*>\s+/gm, '') // ì¸ìš©
            .replace(/---+/g, '') // êµ¬ë¶„ì„ 
            .trim();
    }

    async startRecording(): Promise<void> {
        try {
            // ë§ˆì´í¬ ê¶Œí•œ í™•ì¸
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                throw new Error('ì´ ë¸Œë¼ìš°ì €ëŠ” ì˜¤ë””ì˜¤ ë…¹ìŒì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
            }

            new Notice('ğŸ™ï¸ ë§ˆì´í¬ ì ‘ê·¼ ê¶Œí•œì„ ìš”ì²­í•©ë‹ˆë‹¤...');
            
            const stream = await navigator.mediaDevices.getUserMedia({ 
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    sampleRate: 44100
                }
            });
            
            this.recordedChunks = [];
            
            // MediaRecorder ì§€ì› í™•ì¸
            if (!window.MediaRecorder) {
                throw new Error('ì´ ë¸Œë¼ìš°ì €ëŠ” MediaRecorderë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
            }

            // ì§€ì›ë˜ëŠ” MIME íƒ€ì… í™•ì¸
            let mimeType = 'audio/webm';
            if (!MediaRecorder.isTypeSupported(mimeType)) {
                mimeType = 'audio/ogg';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'audio/mp4';
                }
            }
            
            this.mediaRecorder = new MediaRecorder(stream, { mimeType });
            
            this.mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    this.recordedChunks.push(event.data);
                    console.log('Recording chunk received:', event.data.size, 'bytes');
                }
            };

            this.mediaRecorder.onerror = (event: any) => {
                console.error('MediaRecorder error:', event.error);
                new Notice('âŒ ë…¹ìŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + event.error);
            };

            this.mediaRecorder.start(100); // 100msë§ˆë‹¤ ë°ì´í„° ìˆ˜ì§‘
            console.log('MediaRecorder started, state:', this.mediaRecorder.state);
            new Notice('ğŸ™ï¸ ë…¹ìŒ ì‹œì‘ë¨');
        } catch (error) {
            console.error('Recording start error:', error);
            new Notice('âŒ ë§ˆì´í¬ ì ‘ê·¼ ì‹¤íŒ¨: ' + error.message);
            throw error;
        }
    }

    async stopRecording(): Promise<Blob | null> {
        return new Promise((resolve) => {
            if (!this.mediaRecorder) {
                console.warn('No MediaRecorder to stop');
                resolve(null);
                return;
            }

            if (this.mediaRecorder.state === 'inactive') {
                console.warn('MediaRecorder already stopped');
                resolve(null);
                return;
            }

            this.mediaRecorder.onstop = () => {
                console.log('MediaRecorder stopped, chunks:', this.recordedChunks.length);
                
                if (this.recordedChunks.length === 0) {
                    new Notice('âŒ ë…¹ìŒëœ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤');
                    resolve(null);
                    return;
                }

                const mimeType = this.mediaRecorder?.mimeType || 'audio/webm';
                const blob = new Blob(this.recordedChunks, { type: mimeType });
                console.log('Audio blob created:', blob.size, 'bytes, type:', blob.type);
                
                this.recordedChunks = [];
                
                // ìŠ¤íŠ¸ë¦¼ ì •ì§€
                this.mediaRecorder?.stream.getTracks().forEach(track => {
                    track.stop();
                    console.log('Track stopped:', track.kind);
                });
                this.mediaRecorder = null;
                
                new Notice('â¹ï¸ ë…¹ìŒ ì™„ë£Œ (' + Math.round(blob.size / 1024) + 'KB)');
                resolve(blob);
            };

            this.mediaRecorder.stop();
            console.log('Stopping MediaRecorder...');
        });
    }

    async saveAudioFile(audioBlob: Blob, fileName: string) {
        try {
            // ì¶œë ¥ í´ë” í™•ì¸
            const folderPath = this.settings.outputFolder;
            const folder = this.app.vault.getAbstractFileByPath(folderPath);
            
            if (!folder) {
                await this.app.vault.createFolder(folderPath);
            }

            // Blobì„ ArrayBufferë¡œ ë³€í™˜
            const arrayBuffer = await audioBlob.arrayBuffer();
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            
            // íŒŒì¼ëª…ì— ì´ë¯¸ í™•ì¥ìê°€ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©, ì—†ìœ¼ë©´ ì¶”ê°€
            const baseFileName = fileName.includes('.') ? fileName.split('.')[0] : fileName;
            const extension = fileName.includes('.') ? fileName.split('.').pop() : 'webm';
            const filePath = `${folderPath}/${baseFileName}_${timestamp}.${extension}`;

            // íŒŒì¼ ì €ì¥
            await this.app.vault.createBinary(filePath, arrayBuffer);
            
            console.log('Audio file saved:', filePath, arrayBuffer.byteLength, 'bytes');
            return filePath;
            new Notice(`âœ… ìŒì„± íŒŒì¼ ì €ì¥: ${filePath}`);
        } catch (error) {
            new Notice('âŒ íŒŒì¼ ì €ì¥ ì‹¤íŒ¨: ' + error.message);
        }
    }

    async createDashboard() {
        try {
            const dashboardFolder = this.settings.dashboardFolder;
            const audioFolder = this.settings.outputFolder;
            
            // í´ë” í™•ì¸ ë° ìƒì„±
            if (!this.app.vault.getAbstractFileByPath(dashboardFolder)) {
                await this.app.vault.createFolder(dashboardFolder);
            }
            
            // ëŒ€ì‹œë³´ë“œ íŒŒì¼ ìƒì„±
            const dashboardPath = `${dashboardFolder}/TTS í†µí•© ëŒ€ì‹œë³´ë“œ.md`;
            const dashboardContent = this.generateDashboardContent();
            
            const existingFile = this.app.vault.getAbstractFileByPath(dashboardPath);
            if (existingFile) {
                await this.app.vault.modify(existingFile as any, dashboardContent);
                new Notice('âœ… TTS ëŒ€ì‹œë³´ë“œ ì—…ë°ì´íŠ¸ ì™„ë£Œ');
            } else {
                await this.app.vault.create(dashboardPath, dashboardContent);
                new Notice('âœ… TTS ëŒ€ì‹œë³´ë“œ ìƒì„± ì™„ë£Œ');
            }
            
            // ëŒ€ì‹œë³´ë“œ ì—´ê¸°
            const file = this.app.vault.getAbstractFileByPath(dashboardPath);
            if (file) {
                await this.app.workspace.openLinkText(dashboardPath, '', false);
            }
        } catch (error) {
            new Notice('âŒ ëŒ€ì‹œë³´ë“œ ìƒì„± ì‹¤íŒ¨: ' + error.message);
            console.error('Dashboard creation error:', error);
        }
    }

    generateDashboardContent(): string {
        const now = new Date();
        const dateStr = now.toISOString().split('T')[0];
        
        return `---
title: TTS í†µí•© ëŒ€ì‹œë³´ë“œ
created: ${dateStr}
tags: [tts, dashboard, audio]
---

# ğŸ™ï¸ TTS í†µí•© ëŒ€ì‹œë³´ë“œ

> ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${now.toLocaleString('ko-KR')}

## ğŸ¯ ë¹ ë¥¸ ì‹¤í–‰

\`\`\`button
name ï¿½ ìƒˆ í…ìŠ¤íŠ¸ ì½ê¸°
type command
action TTS ìŒì„± ì½ê¸°
color blue
\`\`\`
^button-new-tts

\`\`\`button
name ğŸ™ï¸ ìŒì„± ë…¹ìŒ
type command
action ë‚´ ìŒì„± ë…¹ìŒí•˜ê¸°
color green
\`\`\`
^button-record

\`\`\`button
name â¹ï¸ ìŒì„± ì •ì§€
type command
action ìŒì„± ì½ê¸° ì •ì§€
color red
\`\`\`
^button-stop

\`\`\`button
name â¸ï¸ ì¼ì‹œì •ì§€/ì¬ê°œ
type command
action ìŒì„± ì½ê¸° ì¼ì‹œì •ì§€/ì¬ê°œ
color default
\`\`\`
^button-pause

\`\`\`button
name ğŸ”„ ëŒ€ì‹œë³´ë“œ ìƒˆë¡œê³ ì¹¨
type command
action TTS ëŒ€ì‹œë³´ë“œ ìƒì„±
color purple
\`\`\`
^button-refresh

---

## ï¿½ğŸ“Š í†µê³„ ìš”ì•½

\`\`\`dataviewjs
const audioFolder = "${this.settings.outputFolder}";
const txtFiles = dv.pages('"' + audioFolder + '"').where(p => p.file.name.endsWith('.txt'));
const audioFiles = dv.pages('"' + audioFolder + '"').where(p => p.file.name.endsWith('.webm') || p.file.name.endsWith('.mp4') || p.file.name.endsWith('.ogg'));

const totalTxt = txtFiles.length;
const totalAudio = audioFiles.length;
const voiceProfiles = audioFiles.where(f => f.file.name.includes('voice_profile')).length;

dv.paragraph(\`
ğŸ“„ **ì €ì¥ëœ TTS í…ìŠ¤íŠ¸**: \${totalTxt}ê°œ  
ğŸµ **ì˜¤ë””ì˜¤ íŒŒì¼**: \${totalAudio}ê°œ  
ğŸ­ **ìŒì„± í”„ë¡œí•„**: \${voiceProfiles}ê°œ
\`);
\`\`\`

---

## ğŸ“„ ì €ì¥ëœ TTS í…ìŠ¤íŠ¸ íŒŒì¼

> ğŸ’¡ **íŒŒì¼ëª…ì„ í´ë¦­í•˜ë©´ ë‚´ìš©ì„ ì½ì–´ì¤ë‹ˆë‹¤**

\`\`\`dataviewjs
const audioFolder = "${this.settings.outputFolder}";
const txtFiles = dv.pages('"' + audioFolder + '"')
    .where(p => p.file.name.endsWith('.txt'))
    .sort(p => p.file.ctime, 'desc');

if (txtFiles.length === 0) {
    dv.paragraph('âŒ ì €ì¥ëœ TTS í…ìŠ¤íŠ¸ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
    dv.paragraph('ğŸ’¡ ìë™ ì €ì¥ ê¸°ëŠ¥ì„ í™œì„±í™”í•˜ë©´ TTSë¡œ ì½ì€ í…ìŠ¤íŠ¸ê°€ ìë™ìœ¼ë¡œ ì €ì¥ë©ë‹ˆë‹¤.');
} else {
    dv.table(
        ['#', 'íŒŒì¼ëª…', 'ìƒì„±ì¼', 'í¬ê¸°', 'ğŸ“– ì½ê¸°'],
        txtFiles.map((p, idx) => {
            const fileName = p.file.name.replace('.txt', '');
            const filePath = p.file.path;
            return [
                idx + 1,
                fileName,
                p.file.ctime ? new Date(p.file.ctime).toLocaleString('ko-KR', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                }) : 'N/A',
                p.file.size ? (p.file.size / 1024).toFixed(1) + ' KB' : 'N/A',
                '[\`â–¶ï¸ ì¬ìƒ\`](' + filePath + ')'
            ];
        })
    );
    
    dv.paragraph('');
    dv.paragraph('**ì‚¬ìš©ë²•**: ğŸ“– ì½ê¸° ì—´ì˜ \`â–¶ï¸ ì¬ìƒ\` ë§í¬ë¥¼ í´ë¦­í•˜ë©´ íŒŒì¼ ë‚´ìš©ì´ TTSë¡œ ì¬ìƒë©ë‹ˆë‹¤.');
}
\`\`\`

---

## ğŸ“‚ í´ë”ë³„ íŒŒì¼ ëª©ë¡

\`\`\`dataviewjs
const baseFolder = "${this.settings.outputFolder}";
const allFiles = dv.pages('"' + baseFolder + '"');

// í´ë”ë³„ë¡œ ê·¸ë£¹í™”
const folders = {};
for (const page of allFiles) {
    const pathParts = page.file.folder.split('/');
    const folderName = pathParts[pathParts.length - 1] || baseFolder;
    
    if (!folders[folderName]) {
        folders[folderName] = [];
    }
    folders[folderName].push(page);
}

// ê° í´ë”ë³„ í…Œì´ë¸” ìƒì„±
for (const [folderName, files] of Object.entries(folders)) {
    if (files.length === 0) continue;
    
    dv.header(3, \`ğŸ“‚ \${folderName} (\${files.length}ê°œ)\`);
    
    dv.table(
        ['íŒŒì¼ëª…', 'ìœ í˜•', 'ìƒì„±ì¼', 'í¬ê¸°', 'ë§í¬'],
        files.map(p => {
            let fileType = 'ğŸ“„ ê¸°íƒ€';
            if (p.file.name.endsWith('.txt')) fileType = 'ï¿½ í…ìŠ¤íŠ¸';
            else if (p.file.name.endsWith('.webm') || p.file.name.endsWith('.mp4')) fileType = 'ğŸµ ì˜¤ë””ì˜¤';
            else if (p.file.name.includes('voice_profile')) fileType = 'ğŸ­ í”„ë¡œí•„';
            
            return [
                p.file.name,
                fileType,
                p.file.ctime ? new Date(p.file.ctime).toLocaleString('ko-KR') : 'N/A',
                p.file.size ? (p.file.size / 1024).toFixed(1) + ' KB' : 'N/A',
                dv.fileLink(p.file.path, false, 'ğŸ”—')
            ];
        })
    );
}
\`\`\`

---

## ğŸ“… ìµœê·¼ í™œë™ (ìµœê·¼ 15ê°œ)

\`\`\`dataviewjs
const audioFolder = "${this.settings.outputFolder}";
const recentFiles = dv.pages('"' + audioFolder + '"')
    .sort(p => p.file.ctime, 'desc')
    .limit(15);

if (recentFiles.length === 0) {
    dv.paragraph('âŒ ìµœê·¼ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
} else {
    dv.table(
        ['#', 'íŒŒì¼ëª…', 'ìœ í˜•', 'ìƒì„±ì¼', 'ë™ì‘'],
        recentFiles.map((p, idx) => {
            let fileType = 'ğŸ“„';
            let action = dv.fileLink(p.file.path, false, 'ğŸ”— ì—´ê¸°');
            
            if (p.file.name.endsWith('.txt')) {
                fileType = 'ğŸ“ TXT';
                action = '[\`â–¶ï¸ ì¬ìƒ\`](' + p.file.path + ')';
            } else if (p.file.name.endsWith('.webm') || p.file.name.endsWith('.mp4')) {
                fileType = 'ğŸµ Audio';
            } else if (p.file.name.includes('voice_profile')) {
                fileType = 'ğŸ­ Profile';
            }
            
            return [
                idx + 1,
                p.file.name,
                fileType,
                p.file.ctime ? new Date(p.file.ctime).toLocaleString('ko-KR', {
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit'
                }) : 'N/A',
                action
            ];
        })
    );
}
\`\`\`

---

## âš™ï¸ í˜„ì¬ ì„¤ì •

\`\`\`dataviewjs
dv.paragraph(\`
**ğŸµ ìŒì„± ëª¨ë“œ**: ${this.settings.voiceMode === 'browser' ? 'ğŸŒ ë¸Œë¼ìš°ì € TTS' : 'ğŸ­ ìƒ˜í”Œ ì˜¤ë””ì˜¤ ì¬ìƒ'}  
**ğŸŒ ì–¸ì–´**: ${this.settings.language}  
**âš¡ ì†ë„**: ${this.settings.speed}x  
**ï¿½ ìŒë†’ì´**: ${this.settings.pitch}  
**ğŸ”Š ë³¼ë¥¨**: ${this.settings.volume}  
**ğŸ’¾ ìë™ ì €ì¥**: ${this.settings.autoSaveAudio ? 'âœ… í™œì„±í™”' : 'âŒ ë¹„í™œì„±í™”'}  
**ğŸ“ ì¶œë ¥ í´ë”**: \\\`${this.settings.outputFolder}\\\`  
**ğŸ­ ìŒì„± í”„ë¡œí•„**: ${this.settings.customVoiceData ? 'âœ… ë“±ë¡ë¨' : 'âŒ ë¯¸ë“±ë¡'}
\`);
\`\`\`

${this.settings.voiceMode === 'custom' ? `
> âš ï¸ **ì»¤ìŠ¤í…€ ìŒì„± ëª¨ë“œ ì•ˆë‚´**  
> í˜„ì¬ ëª¨ë“œëŠ” ë…¹ìŒí•œ ìƒ˜í”Œ ì˜¤ë””ì˜¤ë¥¼ ì¬ìƒí•©ë‹ˆë‹¤.  
> í…ìŠ¤íŠ¸ì— ë”°ë¼ ìŒì„±ì´ ìƒì„±ë˜ì§€ ì•Šìœ¼ë©°, í•­ìƒ ê°™ì€ ìƒ˜í”Œì´ ì¬ìƒë©ë‹ˆë‹¤.  
> í…ìŠ¤íŠ¸ë¥¼ ìŒì„±ìœ¼ë¡œ ë³€í™˜í•˜ë ¤ë©´ "ë¸Œë¼ìš°ì € TTS" ëª¨ë“œë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.
` : ''}

---

## ğŸ’¡ ì‚¬ìš© íŒ

- **TXT íŒŒì¼ ì¬ìƒ**: ìœ„ì˜ "ì €ì¥ëœ TTS í…ìŠ¤íŠ¸ íŒŒì¼" ì„¹ì…˜ì—ì„œ \`â–¶ï¸ ì¬ìƒ\` ë§í¬ë¥¼ í´ë¦­í•˜ë©´ ìë™ìœ¼ë¡œ ë‚´ìš©ì„ ì½ì–´ì¤ë‹ˆë‹¤
- **ìë™ ì €ì¥**: ì„¤ì •ì—ì„œ "ìë™ ì €ì¥" ê¸°ëŠ¥ì„ í™œì„±í™”í•˜ë©´ TTSë¡œ ì½ì€ ëª¨ë“  í…ìŠ¤íŠ¸ê°€ ìë™ìœ¼ë¡œ ì €ì¥ë©ë‹ˆë‹¤
- **ë‹¨ì¶•í‚¤**: 
  - ì„ íƒí•œ í…ìŠ¤íŠ¸ ì½ê¸°: í…ìŠ¤íŠ¸ ì„ íƒ í›„ ì»¤ë§¨ë“œ ì‹¤í–‰
  - ì „ì²´ ë…¸íŠ¸ ì½ê¸°: ì»¤ë§¨ë“œ íŒ”ë ˆíŠ¸ì—ì„œ ì‹¤í–‰
  - ì •ì§€/ì¼ì‹œì •ì§€: ë²„íŠ¼ ë˜ëŠ” ì»¤ë§¨ë“œë¡œ ì œì–´

---

*ğŸ“Œ ì´ ëŒ€ì‹œë³´ë“œëŠ” ìë™ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. "ğŸ”„ ëŒ€ì‹œë³´ë“œ ìƒˆë¡œê³ ì¹¨" ë²„íŠ¼ì„ ëˆŒëŸ¬ ìµœì‹  ì •ë³´ë¡œ ì—…ë°ì´íŠ¸í•˜ì„¸ìš”.*
`;
    }
\`);
\`\`\`

## ğŸ­ ìŒì„± í”„ë¡œí•„

\`\`\`dataviewjs
const audioFolder = "${this.settings.outputFolder}";
const profiles = dv.pages('"' + audioFolder + '"')
    .where(p => p.file.name.includes('voice_profile'))
    .sort(p => p.file.ctime, 'desc');

if (profiles.length === 0) {
    dv.paragraph('âŒ ë“±ë¡ëœ ìŒì„± í”„ë¡œí•„ì´ ì—†ìŠµë‹ˆë‹¤.');
    dv.paragraph('ğŸ’¡ **ì»¤ë§¨ë“œ**: \`ë‚´ ìŒì„± ë…¹ìŒí•˜ê¸°\`ë¡œ ìŒì„± í”„ë¡œí•„ì„ ë“±ë¡í•˜ì„¸ìš”.');
} else {
    dv.table(
        ['íŒŒì¼ëª…', 'ìƒì„±ì¼', 'í¬ê¸°', 'ë§í¬'],
        profiles.map(p => [
            p.file.name,
            p.file.ctime ? new Date(p.file.ctime).toLocaleString('ko-KR') : 'N/A',
            p.file.size ? (p.file.size / 1024).toFixed(1) + ' KB' : 'N/A',
            dv.fileLink(p.file.path, false, 'ì—´ê¸°')
        ])
    );
}
\`\`\`

## ğŸ“ í´ë”ë³„ ì˜¤ë””ì˜¤ ê´€ë¦¬

\`\`\`dataviewjs
const audioFolder = "${this.settings.outputFolder}";
const allFiles = dv.pages('"' + audioFolder + '"')
    .where(p => p.file.name.endsWith('.webm') || p.file.name.endsWith('.mp4') || p.file.name.endsWith('.ogg'))
    .sort(p => p.file.ctime, 'desc');

// í´ë”ë³„ë¡œ ê·¸ë£¹í™”
const folderGroups = {};
for (const file of allFiles) {
    const pathParts = file.file.path.split('/');
    const folderName = pathParts.length > 1 ? pathParts[pathParts.length - 2] : 'Root';
    
    if (!folderGroups[folderName]) {
        folderGroups[folderName] = [];
    }
    folderGroups[folderName].push(file);
}

// í´ë”ë³„ë¡œ í‘œì‹œ
for (const [folderName, files] of Object.entries(folderGroups)) {
    dv.header(3, \`ğŸ“‚ \${folderName} (\${files.length}ê°œ)\`);
    
    dv.table(
        ['íŒŒì¼ëª…', 'ìƒì„±ì¼', 'í¬ê¸°', 'ë§í¬'],
        files.map(p => [
            p.file.name,
            p.file.ctime ? new Date(p.file.ctime).toLocaleString('ko-KR') : 'N/A',
            p.file.size ? (p.file.size / 1024).toFixed(1) + ' KB' : 'N/A',
            dv.fileLink(p.file.path, false, 'â–¶ï¸')
        ])
    );
}
\`\`\`

## ğŸ“… ìµœê·¼ ë…¹ìŒ (ìµœê·¼ 10ê°œ)

\`\`\`dataviewjs
const audioFolder = "${this.settings.outputFolder}";
const recentFiles = dv.pages('"' + audioFolder + '"')
    .where(p => !p.file.name.includes('voice_profile'))
    .where(p => p.file.name.endsWith('.webm') || p.file.name.endsWith('.mp4') || p.file.name.endsWith('.ogg'))
    .sort(p => p.file.ctime, 'desc')
    .limit(10);

if (recentFiles.length === 0) {
    dv.paragraph('âŒ ìµœê·¼ ë…¹ìŒ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.');
} else {
    dv.table(
        ['#', 'íŒŒì¼ëª…', 'ìƒì„±ì¼', 'í¬ê¸°', 'ë§í¬'],
        recentFiles.map((p, idx) => [
            idx + 1,
            p.file.name,
            p.file.ctime ? new Date(p.file.ctime).toLocaleString('ko-KR') : 'N/A',
            p.file.size ? (p.file.size / 1024).toFixed(1) + ' KB' : 'N/A',
            dv.fileLink(p.file.path, false, 'â–¶ï¸')
        ])
    );
}
\`\`\`

## âš™ï¸ í˜„ì¬ ì„¤ì •

\`\`\`dataviewjs
dv.paragraph(\`
**ìŒì„± ëª¨ë“œ**: ${this.settings.voiceMode === 'browser' ? 'ğŸŒ ë¸Œë¼ìš°ì € TTS' : 'ğŸ­ ë‚´ ëª©ì†Œë¦¬ (ë…¹ìŒ)'}  
**ì–¸ì–´**: ${this.settings.language}  
**ì†ë„**: ${this.settings.speed}x  
**ìŒë†’ì´**: ${this.settings.pitch}  
**ë³¼ë¥¨**: ${this.settings.volume}  
**ì¶œë ¥ í´ë”**: \\\`${this.settings.outputFolder}\\\`  
**ìŒì„± í”„ë¡œí•„**: ${this.settings.customVoiceData ? 'âœ… ë“±ë¡ë¨ (ì¬ìƒ ê°€ëŠ¥)' : 'âŒ ë¯¸ë“±ë¡'}
\`);
\`\`\`

${this.settings.customVoiceData ? `
> ğŸ’¡ **ì»¤ìŠ¤í…€ ìŒì„± ëª¨ë“œ**: ì„¤ì •ì—ì„œ "ì»¤ìŠ¤í…€ ìŒì„±" ëª¨ë“œë¥¼ ì„ íƒí•˜ë©´ ë…¹ìŒí•œ ë‚´ ëª©ì†Œë¦¬ ìƒ˜í”Œì´ ì¬ìƒë©ë‹ˆë‹¤.  
> í˜„ì¬ëŠ” ë…¹ìŒëœ ìƒ˜í”Œì´ ê·¸ëŒ€ë¡œ ì¬ìƒë˜ë©°, í…ìŠ¤íŠ¸ì— ë”°ë¼ ìŒì„±ì´ ìƒì„±ë˜ì§€ëŠ” ì•ŠìŠµë‹ˆë‹¤.
` : ''}

## ğŸ¯ ë¹ ë¥¸ ì‹¤í–‰

\`\`\`button
name ğŸ“ ìƒˆ í…ìŠ¤íŠ¸ ì½ê¸°
type command
action TTS ìŒì„± ì½ê¸°
\`\`\`

\`\`\`button
name ğŸ™ï¸ ìŒì„± ë…¹ìŒ
type command
action ë‚´ ìŒì„± ë…¹ìŒí•˜ê¸°
\`\`\`

\`\`\`button
name ğŸ”„ ëŒ€ì‹œë³´ë“œ ìƒˆë¡œê³ ì¹¨
type command
action TTS ëŒ€ì‹œë³´ë“œ ìƒì„±
\`\`\`

\`\`\`button
name â¹ï¸ ìŒì„± ì •ì§€
type command
action ìŒì„± ì½ê¸° ì •ì§€
\`\`\`

## ğŸ“– ì‚¬ìš© ê°€ì´ë“œ

### ê¸°ë³¸ ì‚¬ìš©ë²•
1. **í…ìŠ¤íŠ¸ ì„ íƒ í›„ ì½ê¸°**: í…ìŠ¤íŠ¸ ì„ íƒ â†’ ìš°í´ë¦­ â†’ "ì„ íƒí•œ í…ìŠ¤íŠ¸ ì½ê¸°"
2. **ì „ì²´ ë…¸íŠ¸ ì½ê¸°**: \`Ctrl+P\` â†’ "ì „ì²´ ë…¸íŠ¸ ì½ê¸°"
3. **ìŒì„± ë…¹ìŒ**: \`Ctrl+P\` â†’ "ë‚´ ìŒì„± ë…¹ìŒí•˜ê¸°"

### ìŒì„± í”„ë¡œí•„ ë“±ë¡
1. ì¡°ìš©í•œ í™˜ê²½ì—ì„œ ë…¹ìŒ ì‹œì‘
2. 10ì´ˆ ì´ìƒ ìì—°ìŠ¤ëŸ½ê²Œ ë§í•˜ê¸°
3. ë…¹ìŒ ì™„ë£Œ í›„ ìë™ ì €ì¥
4. ì„¤ì •ì—ì„œ "ì»¤ìŠ¤í…€ ìŒì„±" ëª¨ë“œ í™œì„±í™”
5. **ìƒ˜í”Œ ì¬ìƒ**: ë…¹ìŒí•œ ìŒì„± ìƒ˜í”Œì´ ê·¸ëŒ€ë¡œ ì¬ìƒë©ë‹ˆë‹¤

> âš ï¸ **ì°¸ê³ **: í˜„ì¬ëŠ” ë…¹ìŒëœ ìƒ˜í”Œì„ ê·¸ëŒ€ë¡œ ì¬ìƒí•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.  
> í…ìŠ¤íŠ¸ë¥¼ ë‚´ ëª©ì†Œë¦¬ë¡œ ë³€í™˜í•˜ëŠ” TTS ê¸°ëŠ¥ì€ ë³„ë„ì˜ AI ëª¨ë¸ì´ í•„ìš”í•©ë‹ˆë‹¤.

### í´ë” ê´€ë¦¬
- **ìŒì„± íŒŒì¼ ìœ„ì¹˜**: \`${this.settings.outputFolder}\`
- **íŒŒì¼ í˜•ì‹**: WebM, OGG, MP4
- **ì •ë¦¬ ë°©ë²•**: í•˜ìœ„ í´ë” ìƒì„± ê°€ëŠ¥

---

*ì´ ëŒ€ì‹œë³´ë“œëŠ” ìë™ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. \`Ctrl+P\` â†’ "TTS ëŒ€ì‹œë³´ë“œ ìƒì„±"ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•˜ì„¸ìš”.*
`;
    }

    async onunload() {
        this.stopSpeaking();
        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
            this.mediaRecorder.stop();
        }
    }

    async loadSettings() {
        this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    }

    async saveSettings() {
        await this.saveData(this.settings);
    }
}

class TTSReaderModal extends Modal {
    plugin: TTSVoiceReaderPlugin;
    textArea: HTMLTextAreaElement;

    constructor(app: App, plugin: TTSVoiceReaderPlugin) {
        super(app);
        this.plugin = plugin;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass('tts-reader-modal');

        contentEl.createEl('h2', { text: 'ğŸ”Š TTS ìŒì„± ì½ê¸°' });

        // í…ìŠ¤íŠ¸ ì…ë ¥
        this.textArea = contentEl.createEl('textarea', {
            attr: { placeholder: 'ì½ì„ í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•˜ì„¸ìš”...' }
        });
        this.textArea.style.width = '100%';
        this.textArea.style.minHeight = '200px';
        this.textArea.style.marginBottom = '12px';

        // ë²„íŠ¼ ì»¨í…Œì´ë„ˆ
        const buttonContainer = contentEl.createDiv({ cls: 'tts-button-container' });

        // ì½ê¸° ë²„íŠ¼
        const speakBtn = buttonContainer.createEl('button', { 
            text: 'â–¶ï¸ ì½ê¸°',
            cls: 'mod-cta'
        });
        speakBtn.onclick = () => {
            const text = this.textArea.value;
            if (text.trim()) {
                this.plugin.speakText(text);
            } else {
                new Notice('í…ìŠ¤íŠ¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”');
            }
        };

        // ì •ì§€ ë²„íŠ¼
        const stopBtn = buttonContainer.createEl('button', { text: 'â¹ï¸ ì •ì§€' });
        stopBtn.onclick = () => {
            this.plugin.stopSpeaking();
        };

        // ì¼ì‹œì •ì§€ ë²„íŠ¼
        const pauseBtn = buttonContainer.createEl('button', { text: 'â¸ï¸ ì¼ì‹œì •ì§€/ì¬ê°œ' });
        pauseBtn.onclick = () => {
            this.plugin.togglePause();
        };
    }

    onClose() {
        const { contentEl } = this;
        contentEl.empty();
    }
}

class VoiceRecordModal extends Modal {
    plugin: TTSVoiceReaderPlugin;
    isRecording: boolean = false;
    recordButton: HTMLButtonElement;
    statusText: HTMLDivElement;
    recordingTime: number = 0;
    timerInterval: number | null = null;

    constructor(app: App, plugin: TTSVoiceReaderPlugin) {
        super(app);
        this.plugin = plugin;
    }

    onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass('voice-record-modal');

        contentEl.createEl('h2', { text: 'ğŸ™ï¸ ë‚´ ìŒì„± ë…¹ìŒí•˜ê¸°' });
        
        contentEl.createEl('p', { 
            text: '10ì´ˆ~60ì´ˆ ë™ì•ˆ ìì—°ìŠ¤ëŸ½ê²Œ ë§í•´ì£¼ì„¸ìš”. ë…¹ìŒëœ ìŒì„±ì€ ìŒì„± í”„ë¡œí•„ë¡œ ì €ì¥ë©ë‹ˆë‹¤.',
            cls: 'voice-record-desc'
        });

        // ìƒíƒœ í‘œì‹œ
        this.statusText = contentEl.createDiv({ cls: 'recording-status' });
        this.statusText.textContent = 'ì¤€ë¹„ë¨';

        // íƒ€ì´ë¨¸ í‘œì‹œ
        const timerDisplay = contentEl.createDiv({ cls: 'recording-timer' });
        timerDisplay.textContent = '00:00';

        // ë…¹ìŒ ë²„íŠ¼
        this.recordButton = contentEl.createEl('button', { 
            text: 'ğŸ”´ ë…¹ìŒ ì‹œì‘',
            cls: 'mod-cta record-button'
        });

        this.recordButton.onclick = async () => {
            if (!this.isRecording) {
                await this.startRecording(timerDisplay);
            } else {
                await this.stopRecording();
            }
        };

        // ì•ˆë‚´ í…ìŠ¤íŠ¸
        const guide = contentEl.createDiv({ cls: 'recording-guide' });
        guide.innerHTML = `
            <h4>ğŸ“‹ ë…¹ìŒ ê°€ì´ë“œ:</h4>
            <ul>
                <li>ì¡°ìš©í•œ í™˜ê²½ì—ì„œ ë…¹ìŒí•˜ì„¸ìš”</li>
                <li>ë§ˆì´í¬ì™€ ì ë‹¹í•œ ê±°ë¦¬ë¥¼ ìœ ì§€í•˜ì„¸ìš”</li>
                <li>ìì—°ìŠ¤ëŸ½ê³  ë˜ë°•ë˜ë°• ë§í•´ì£¼ì„¸ìš”</li>
                <li>ìµœì†Œ 10ì´ˆ ì´ìƒ ë…¹ìŒí•´ì£¼ì„¸ìš”</li>
                <li>ì˜ˆì‹œ: "ì•ˆë…•í•˜ì„¸ìš”. ì €ëŠ” [ì´ë¦„]ì…ë‹ˆë‹¤. ì˜¤ëŠ˜ì€ ë‚ ì”¨ê°€ ì¢‹ë„¤ìš”. ì˜µì‹œë””ì–¸ìœ¼ë¡œ ê³µë¶€ ì¤‘ì…ë‹ˆë‹¤."</li>
            </ul>
        `;
    }

    async startRecording(timerDisplay: HTMLDivElement) {
        try {
            this.isRecording = true;
            this.recordButton.textContent = 'â¹ï¸ ë…¹ìŒ ì¤‘ì§€';
            this.recordButton.removeClass('mod-cta');
            this.recordButton.addClass('mod-warning');
            this.statusText.textContent = 'ğŸ™ï¸ ë…¹ìŒ ì¤‘...';
            this.statusText.style.color = 'var(--text-error)';
            
            this.recordingTime = 0;
            this.timerInterval = window.setInterval(() => {
                this.recordingTime++;
                const minutes = Math.floor(this.recordingTime / 60);
                const seconds = this.recordingTime % 60;
                timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }, 1000);

            await this.plugin.startRecording();
        } catch (error) {
            this.isRecording = false;
            this.recordButton.textContent = 'ğŸ”´ ë…¹ìŒ ì‹œì‘';
            this.recordButton.removeClass('mod-warning');
            this.recordButton.addClass('mod-cta');
            this.statusText.textContent = 'âŒ ë…¹ìŒ ì‹œì‘ ì‹¤íŒ¨';
            this.statusText.style.color = 'var(--text-error)';
            
            if (this.timerInterval) {
                clearInterval(this.timerInterval);
                this.timerInterval = null;
            }
        }
    }

    async stopRecording() {
        this.isRecording = false;
        this.recordButton.textContent = 'ï¿½ ì²˜ë¦¬ ì¤‘...';
        this.recordButton.removeClass('mod-warning');
        this.recordButton.disabled = true;
        this.statusText.textContent = 'ì²˜ë¦¬ ì¤‘...';
        this.statusText.style.color = 'var(--text-muted)';

        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }

        try {
            const audioBlob = await this.plugin.stopRecording();

            if (audioBlob && audioBlob.size > 0) {
                this.statusText.textContent = 'ğŸ’¾ ì €ì¥ ì¤‘...';
                
                // Base64ë¡œ ë³€í™˜í•˜ì—¬ ì €ì¥
                const reader = new FileReader();
                reader.onloadend = async () => {
                    try {
                        const base64 = reader.result as string;
                        this.plugin.settings.customVoiceData = base64;
                        await this.plugin.saveSettings();
                        
                        // ìŒì„± íŒŒì¼ë„ ì €ì¥
                        const extension = audioBlob.type.includes('webm') ? 'webm' : 
                                        audioBlob.type.includes('ogg') ? 'ogg' : 'mp4';
                        await this.plugin.saveAudioFile(audioBlob, `my_voice_profile.${extension}`);
                        
                        this.statusText.textContent = 'âœ… ë…¹ìŒ ì™„ë£Œ! ìŒì„± í”„ë¡œí•„ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.';
                        this.statusText.style.color = 'var(--text-success)';
                        new Notice('âœ… ìŒì„± í”„ë¡œí•„ ì €ì¥ ì™„ë£Œ! (' + Math.round(audioBlob.size / 1024) + 'KB)');
                        
                        setTimeout(() => this.close(), 2000);
                    } catch (error) {
                        this.statusText.textContent = 'âŒ ì €ì¥ ì‹¤íŒ¨: ' + error.message;
                        this.statusText.style.color = 'var(--text-error)';
                        this.recordButton.disabled = false;
                        this.recordButton.textContent = 'ğŸ”´ ë…¹ìŒ ì‹œì‘';
                        this.recordButton.addClass('mod-cta');
                    }
                };
                reader.onerror = () => {
                    this.statusText.textContent = 'âŒ íŒŒì¼ ì½ê¸° ì‹¤íŒ¨';
                    this.statusText.style.color = 'var(--text-error)';
                    this.recordButton.disabled = false;
                    this.recordButton.textContent = 'ğŸ”´ ë…¹ìŒ ì‹œì‘';
                    this.recordButton.addClass('mod-cta');
                };
                reader.readAsDataURL(audioBlob);
            } else {
                this.statusText.textContent = 'âŒ ë…¹ìŒ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.';
                this.statusText.style.color = 'var(--text-error)';
                this.recordButton.disabled = false;
                this.recordButton.textContent = 'ğŸ”´ ë…¹ìŒ ì‹œì‘';
                this.recordButton.addClass('mod-cta');
            }
        } catch (error) {
            this.statusText.textContent = 'âŒ ë…¹ìŒ ì¤‘ì§€ ì‹¤íŒ¨: ' + error.message;
            this.statusText.style.color = 'var(--text-error)';
            this.recordButton.disabled = false;
            this.recordButton.textContent = 'ğŸ”´ ë…¹ìŒ ì‹œì‘';
            this.recordButton.addClass('mod-cta');
        }
    }

    onClose() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
        }
        const { contentEl } = this;
        contentEl.empty();
    }
}

class TTSSettingTab extends PluginSettingTab {
    plugin: TTSVoiceReaderPlugin;

    constructor(app: App, plugin: TTSVoiceReaderPlugin) {
        super(app, plugin);
        this.plugin = plugin;
    }

    display(): void {
        const { containerEl } = this;
        containerEl.empty();

        containerEl.createEl('h2', { text: 'TTS ìŒì„± ì„¤ì •' });

        // ìŒì„± ëª¨ë“œ
        new Setting(containerEl)
            .setName('ìŒì„± ëª¨ë“œ')
            .setDesc('ë¸Œë¼ìš°ì € TTS: í…ìŠ¤íŠ¸ë¥¼ ìŒì„±ìœ¼ë¡œ ë³€í™˜ | ì»¤ìŠ¤í…€: ë…¹ìŒí•œ ìƒ˜í”Œ ì˜¤ë””ì˜¤ ì¬ìƒ (í…ìŠ¤íŠ¸ì™€ ë¬´ê´€)')
            .addDropdown(dropdown => dropdown
                .addOption('browser', 'ğŸ”Š ë¸Œë¼ìš°ì € TTS (ê¶Œì¥)')
                .addOption('custom', 'ğŸ­ ë‚´ ëª©ì†Œë¦¬ ìƒ˜í”Œ ì¬ìƒ')
                .setValue(this.plugin.settings.voiceMode)
                .onChange(async (value: 'browser' | 'custom') => {
                    this.plugin.settings.voiceMode = value;
                    await this.plugin.saveSettings();
                    if (value === 'custom' && !this.plugin.settings.customVoiceData) {
                        new Notice('âš ï¸ ë¨¼ì € ìŒì„±ì„ ë…¹ìŒí•´ì£¼ì„¸ìš”');
                    } else if (value === 'custom') {
                        new Notice('âš ï¸ ì»¤ìŠ¤í…€ ëª¨ë“œëŠ” ë…¹ìŒí•œ ìƒ˜í”Œë§Œ ì¬ìƒí•©ë‹ˆë‹¤ (TTS ì•„ë‹˜)');
                    }
                    this.display(); // ì„¤ì • í™”ë©´ ìƒˆë¡œê³ ì¹¨
                }));

        // ë¸Œë¼ìš°ì € ìŒì„± ì„ íƒ
        new Setting(containerEl)
            .setName('ë¸Œë¼ìš°ì € ìŒì„±')
            .setDesc('ì‚¬ìš©í•  ìŒì„±ì„ ì„ íƒí•˜ì„¸ìš”')
            .addDropdown(dropdown => {
                this.plugin.availableVoices.forEach(voice => {
                    dropdown.addOption(voice.name, `${voice.name} (${voice.lang})`);
                });
                dropdown.setValue(this.plugin.settings.browserVoice);
                dropdown.onChange(async (value) => {
                    this.plugin.settings.browserVoice = value;
                    await this.plugin.saveSettings();
                });
                return dropdown;
            });

        // ì–¸ì–´
        new Setting(containerEl)
            .setName('ì–¸ì–´')
            .setDesc('ìŒì„± ì½ê¸° ì–¸ì–´')
            .addDropdown(dropdown => dropdown
                .addOption('ko-KR', 'í•œêµ­ì–´')
                .addOption('en-US', 'ì˜ì–´')
                .addOption('ja-JP', 'ì¼ë³¸ì–´')
                .addOption('zh-CN', 'ì¤‘êµ­ì–´')
                .setValue(this.plugin.settings.language)
                .onChange(async (value) => {
                    this.plugin.settings.language = value;
                    await this.plugin.saveSettings();
                }));

        // ì†ë„
        new Setting(containerEl)
            .setName('ì½ê¸° ì†ë„')
            .setDesc('ìŒì„± ì½ê¸° ì†ë„ (0.5 = ëŠë¦¼, 1.0 = ë³´í†µ, 2.0 = ë¹ ë¦„)')
            .addSlider(slider => slider
                .setLimits(0.5, 2.0, 0.1)
                .setValue(this.plugin.settings.speed)
                .setDynamicTooltip()
                .onChange(async (value) => {
                    this.plugin.settings.speed = value;
                    await this.plugin.saveSettings();
                }));

        // ìŒë†’ì´
        new Setting(containerEl)
            .setName('ìŒë†’ì´')
            .setDesc('ìŒì„±ì˜ ë†’ë‚®ì´ (0.5 = ë‚®ìŒ, 1.0 = ë³´í†µ, 2.0 = ë†’ìŒ)')
            .addSlider(slider => slider
                .setLimits(0.5, 2.0, 0.1)
                .setValue(this.plugin.settings.pitch)
                .setDynamicTooltip()
                .onChange(async (value) => {
                    this.plugin.settings.pitch = value;
                    await this.plugin.saveSettings();
                }));

        // ìŒëŸ‰
        new Setting(containerEl)
            .setName('ìŒëŸ‰')
            .setDesc('ìŒì„±ì˜ í¬ê¸° (0.0 = ë¬´ìŒ, 1.0 = ìµœëŒ€)')
            .addSlider(slider => slider
                .setLimits(0.0, 1.0, 0.1)
                .setValue(this.plugin.settings.volume)
                .setDynamicTooltip()
                .onChange(async (value) => {
                    this.plugin.settings.volume = value;
                    await this.plugin.saveSettings();
                }));

        // ìë™ ì €ì¥
        new Setting(containerEl)
            .setName('ğŸ“ ìë™ ì €ì¥')
            .setDesc('TTS ì½ê¸°ê°€ ì™„ë£Œë˜ë©´ í…ìŠ¤íŠ¸ë¥¼ ìë™ìœ¼ë¡œ íŒŒì¼ë¡œ ì €ì¥')
            .addToggle(toggle => toggle
                .setValue(this.plugin.settings.autoSaveAudio)
                .onChange(async (value) => {
                    this.plugin.settings.autoSaveAudio = value;
                    await this.plugin.saveSettings();
                    new Notice(value ? 'âœ… ìë™ ì €ì¥ í™œì„±í™”' : 'âŒ ìë™ ì €ì¥ ë¹„í™œì„±í™”');
                }));

        // ì¶œë ¥ í´ë”
        new Setting(containerEl)
            .setName('ìŒì„± íŒŒì¼ ì €ì¥ í´ë”')
            .setDesc('ë…¹ìŒëœ ìŒì„± íŒŒì¼ì„ ì €ì¥í•  í´ë”')
            .addText(text => text
                .setPlaceholder('TTS Audio')
                .setValue(this.plugin.settings.outputFolder)
                .onChange(async (value) => {
                    this.plugin.settings.outputFolder = value;
                    await this.plugin.saveSettings();
                }));

        // í˜„ì¬ ëª¨ë“œ ìƒíƒœ í‘œì‹œ
        const modeStatus = containerEl.createDiv({
            cls: 'current-mode-status'
        });
        modeStatus.style.padding = '12px';
        modeStatus.style.backgroundColor = 'var(--background-secondary)';
        modeStatus.style.borderRadius = '8px';
        modeStatus.style.marginTop = '15px';
        modeStatus.style.marginBottom = '15px';
        modeStatus.style.borderLeft = '4px solid var(--interactive-accent)';

        const modeText = this.plugin.settings.voiceMode === 'browser' 
            ? 'ğŸŒ í˜„ì¬ ëª¨ë“œ: ë¸Œë¼ìš°ì € TTS' 
            : 'ğŸ­ í˜„ì¬ ëª¨ë“œ: ìƒ˜í”Œ ì˜¤ë””ì˜¤ ì¬ìƒ';
        const modeDesc = this.plugin.settings.voiceMode === 'browser'
            ? 'ë¸Œë¼ìš°ì € ê¸°ë³¸ ìŒì„±ìœ¼ë¡œ í…ìŠ¤íŠ¸ë¥¼ ì½ì–´ì¤ë‹ˆë‹¤'
            : this.plugin.settings.customVoiceData 
                ? 'âš ï¸ ë…¹ìŒí•œ ìƒ˜í”Œ ì˜¤ë””ì˜¤ë§Œ ì¬ìƒë©ë‹ˆë‹¤ (TTS ì•„ë‹˜)'
                : 'âš ï¸ ìŒì„± í”„ë¡œí•„ì´ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ë…¹ìŒí•´ì£¼ì„¸ìš”!';
        
        modeStatus.innerHTML = `
            <div style="font-weight: bold; font-size: 1.1em; margin-bottom: 4px;">${modeText}</div>
            <div style="color: var(--text-muted); font-size: 0.9em;">${modeDesc}</div>
            <div style="color: var(--text-muted); font-size: 0.85em; margin-top: 4px;">
                ${this.plugin.settings.autoSaveAudio ? 'ğŸ’¾ ìë™ ì €ì¥: ì¼œì§' : ''}
            </div>
        `;

        // í…ŒìŠ¤íŠ¸ ë²„íŠ¼
        new Setting(containerEl)
            .setName('ìŒì„± í…ŒìŠ¤íŠ¸')
            .setDesc('í˜„ì¬ ì„¤ì •ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ìŒì„±ì„ ë“¤ì–´ë³´ì„¸ìš”')
            .addButton(button => button
                .setButtonText('ğŸ”Š í…ŒìŠ¤íŠ¸')
                .onClick(() => {
                    const testMode = this.plugin.settings.voiceMode === 'browser' ? 'ë¸Œë¼ìš°ì € ëª¨ë“œ' : 'ì»¤ìŠ¤í…€ ëª¨ë“œ';
                    new Notice(`ğŸµ ${testMode}ë¡œ ì¬ìƒ ì¤‘...`);
                    this.plugin.speakText('ì•ˆë…•í•˜ì„¸ìš”. ì´ê²ƒì€ ìŒì„± í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤. ì˜µì‹œë””ì–¸ TTS í”ŒëŸ¬ê·¸ì¸ì´ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•˜ê³  ìˆìŠµë‹ˆë‹¤.');
                }));

        // í´ë” ì„¤ì •
        containerEl.createEl('h2', { text: 'ğŸ“ í´ë” ì„¤ì •' });

        new Setting(containerEl)
            .setName('ì¶œë ¥ í´ë”')
            .setDesc('ë…¹ìŒëœ ìŒì„± íŒŒì¼ì´ ì €ì¥ë  í´ë”')
            .addText(text => text
                .setPlaceholder('TTS Audio')
                .setValue(this.plugin.settings.outputFolder)
                .onChange(async (value) => {
                    this.plugin.settings.outputFolder = value;
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('ëŒ€ì‹œë³´ë“œ í´ë”')
            .setDesc('TTS ëŒ€ì‹œë³´ë“œê°€ ìƒì„±ë  í´ë”')
            .addText(text => text
                .setPlaceholder('TTS Dashboard')
                .setValue(this.plugin.settings.dashboardFolder)
                .onChange(async (value) => {
                    this.plugin.settings.dashboardFolder = value;
                    await this.plugin.saveSettings();
                }));

        new Setting(containerEl)
            .setName('ëŒ€ì‹œë³´ë“œ ìƒì„±')
            .setDesc('TTS íŒŒì¼ ê´€ë¦¬ ë° í†µê³„ë¥¼ ìœ„í•œ ëŒ€ì‹œë³´ë“œ ìƒì„±')
            .addButton(button => button
                .setButtonText('ğŸ“Š ëŒ€ì‹œë³´ë“œ ìƒì„±')
                .setCta()
                .onClick(async () => {
                    await this.plugin.createDashboard();
                }));

        // ë…¹ìŒ ë²„íŠ¼
        containerEl.createEl('h2', { text: 'ğŸ™ï¸ ìŒì„± ë…¹ìŒ' });

        new Setting(containerEl)
            .setName('ìŒì„± ë…¹ìŒ')
            .setDesc('ë‚´ ëª©ì†Œë¦¬ë¥¼ ë…¹ìŒí•˜ì—¬ ìŒì„± í”„ë¡œí•„ ìƒì„±')
            .addButton(button => button
                .setButtonText('ğŸ™ï¸ ë…¹ìŒí•˜ê¸°')
                .onClick(() => {
                    new VoiceRecordModal(this.app, this.plugin).open();
                }));

        // ë…¹ìŒ ìƒíƒœ
        if (this.plugin.settings.customVoiceData) {
            const statusDiv = containerEl.createDiv({ 
                text: 'âœ… ìŒì„± í”„ë¡œí•„ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤',
                cls: 'voice-profile-status'
            });
            statusDiv.style.color = 'var(--text-success)';
            statusDiv.style.padding = '10px';
            statusDiv.style.backgroundColor = 'var(--background-secondary)';
            statusDiv.style.borderRadius = '8px';
            statusDiv.style.marginTop = '10px';

            // ìŒì„± í”„ë¡œí•„ í…ŒìŠ¤íŠ¸ ë²„íŠ¼
            new Setting(containerEl)
                .setName('ìŒì„± í”„ë¡œí•„ í…ŒìŠ¤íŠ¸')
                .setDesc('ë…¹ìŒí•œ ë‚´ ëª©ì†Œë¦¬ ìƒ˜í”Œì„ ì¬ìƒí•´ë´…ë‹ˆë‹¤')
                .addButton(button => button
                    .setButtonText('ğŸ”Š ìƒ˜í”Œ ì¬ìƒ')
                    .onClick(async () => {
                        await this.plugin.speakWithCustomVoice('ì•ˆë…•í•˜ì„¸ìš”. ì´ê²ƒì€ ë…¹ìŒëœ ìŒì„± í”„ë¡œí•„ í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤.');
                    }));

            // ìŒì„± í”„ë¡œí•„ ì‚­ì œ
            new Setting(containerEl)
                .setName('ìŒì„± í”„ë¡œí•„ ì‚­ì œ')
                .setDesc('ì €ì¥ëœ ìŒì„± í”„ë¡œí•„ì„ ì‚­ì œí•©ë‹ˆë‹¤')
                .addButton(button => button
                    .setButtonText('ğŸ—‘ï¸ ì‚­ì œ')
                    .setWarning()
                    .onClick(async () => {
                        if (confirm('ìŒì„± í”„ë¡œí•„ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) {
                            this.plugin.settings.customVoiceData = null;
                            await this.plugin.saveSettings();
                            new Notice('âœ… ìŒì„± í”„ë¡œí•„ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤');
                            this.display(); // ì„¤ì • í™”ë©´ ìƒˆë¡œê³ ì¹¨
                        }
                    }));
        }
    }
}
